# Implementation Plan: Streaming Pipeline & Dashboard UI

## 1. Context & Goal
The current "Batch & Wait" architecture creates a poor user experience: the user waits minutes with no feedback before seeing any data.
We will refactor the system to a **Streaming Pipeline**. As soon as the Offscreen Crawler finds a study, it pushes it to the Background. The Background immediately queues it for Lichess enrichment *in parallel* with the ongoing crawl.
We will also replace the cramped Popup with a full-page **Dashboard Tab** to display the large data table (90+ lines) with filtering and sorting capabilities.

## 2. Memory Update
Refactoring to a streaming architecture. Content Script now captures the Course Name. Offscreen Crawler emits results per-study. Background manages a concurrent Lichess enrichment queue. Created a new Dashboard entry point for data visualization.

## 3. Step-by-Step Instructions

### Step 1: Update Data Structures
**Action:** Modify `src/types.ts`
**Description:**
- **Add to `CrawlTask`:** `courseName: string` (The "Hidden Column" for filtering).
- **New Message:** `STUDY_EXTRACTED` (Payload: `rawLines: RawExtractedLine[]`).
- **New Message:** `LINE_ENRICHED` (Payload: `line: ExtractedLine`).
- **Update Status:** Track `queueLength` in `StatusResponse` to show pending Lichess requests.

### Step 2: Capture Course Metadata (Phase 1)
**Action:** Modify `src/content/index.ts`
**Description:**
- **Logic:** Before scanning chapters, find the Course Title (usually the `h1` element on the page).
- **Pass it:** Add this `courseName` to every `CrawlTask` object generated.

### Step 3: Stream from Crawler (Phase 2)
**Action:** Modify `src/offscreen/crawler.ts`
**Description:**
- **Refactor `extractAllStudies`:**
    - Inside the loop, immediately after `fetchWithTimeout` returns lines:
    - Send `STUDY_EXTRACTED` message to Background with the new lines.
    - **Do not** wait to collect all results in a giant array.
    - Keep the 1.5s cooldown to be polite to Chessly.

### Step 4: Background Queue Engine
**Action:** Modify `src/background/index.ts`
**Description:**
- **State:** Add a `enrichmentQueue: string[]` (List of FENs/Lines waiting for API).
- **Listener:** Handle `STUDY_EXTRACTED`.
    - Convert moves to FEN immediately.
    - Check Cache.
    - If uncached, push to `enrichmentQueue`.
    - If cached, broadcast `LINE_ENRICHED` immediately.
- **Worker Loop:** Implement a `processQueue()` function that runs continuously if queue > 0.
    - Pop item -> Call Lichess -> Broadcast `LINE_ENRICHED` -> Store -> Wait 1s -> Repeat.
    - This ensures we never exceed 1 req/sec but always utilize the available bandwidth.

### Step 5: Dashboard Entry Point
**Action:** Create `src/dashboard/index.html` and `src/dashboard/main.tsx`
**Description:**
- Standard Vite React entry point (similar to Popup/Offscreen).
- **Config:** Update `vite.config.ts` to include `dashboard: 'src/dashboard/index.html'` in `rollupOptions`.

### Step 6: Dashboard UI (`src/dashboard/App.tsx`)
**Action:** Create `src/dashboard/App.tsx`
**Description:**
- **Layout:** A full-width data grid.
- **Components:**
    - **Header:** "Chessly Explorer" + Export Button.
    - **Filter Bar:** Dropdown for "Opening/Course" (derived from unique `courseName` values).
    - **Table:**
        - Columns: Opening, Chapter, Study, Variation, Moves, Stats (White/Draw/Black).
        - **Sticky Header:** Use CSS `position: sticky` for column headers.
- **Logic:**
    - On mount, fetch all data from `chrome.storage.local`.
    - Listen for `LINE_ENRICHED` messages to append rows in real-time.

### Step 7: Update Popup to Open Dashboard
**Action:** Modify `src/popup/App.tsx`
**Description:**
- Replace the "Export" button with "Open Dashboard".
- **Action:** `chrome.tabs.create({ url: 'src/dashboard/index.html' })`.
- Show a live counter: "Queued for Lichess: X".

## 4. Verification
1.  Run `npm run build`.
2.  Reload Extension.
3.  Go to Chessly, click "Start Extraction".
4.  **Observe:** Popup status updates immediately.
5.  Click "Open Dashboard".
6.  **Observe:** A new tab opens. Rows should appear one by one every ~1.5s (from Crawler) or 1s (from Lichess), filling the table dynamically.
