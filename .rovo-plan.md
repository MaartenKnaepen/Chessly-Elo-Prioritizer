You are correct that simple HTML/JS extensions can be loaded directly. However, because we are using **React** (for the UI) and **TypeScript** (for safety/speed), **yes, we need a build step.**

Chrome cannot execute `.tsx` or `.ts` files directly. It only understands standard JavaScript (`.js`).

**The Good News:**
We will configure the project so you can run `npm run dev`.
1.  This creates a `dist` folder.
2.  You load that `dist` folder into Chrome **once**.
3.  As we write code, Vite re-compiles it instantly (milliseconds). You just have to click "Refresh" in Chrome for the background script, but the popup often updates automatically (HMR).

Here is the plan to set up this modern, high-performance architecture.

```markdown
# Implementation Plan: Initialize High-Performance Extension

## 1. Context & Goal
Initialize a Chrome Extension project using **Vite**, **React**, and **TypeScript**. This architecture supports the complex requirement of converting chess moves (extracted via a hidden crawler) into FEN strings and querying the Lichess API efficiently without blocking the UI.

## 2. Memory Update
Initialized project structure with Vite+React+TS for a Manifest V3 extension. Added `chess.js` for logic and set up the Offscreen Document architecture for the web crawler.

## 3. Step-by-Step Instructions

### Step 1: Scaffold Project Structure
**Action:** Create Files
**Description:**
Initialize a standard Vite structure.
- **Root:** `package.json`, `vite.config.ts`, `tsconfig.json`.
- **Source:** `src/manifest.json`, `src/background/`, `src/popup/`, `src/offscreen/`.

**Commands:**
```bash
# Rovo: Execute these if the repo is empty, otherwise create files manually
npm create vite@latest . -- --template react-ts
npm install --save-dev @crxjs/vite-plugin@beta
npm install chess.js
```

### Step 2: Configuration (`vite.config.ts` & `tsconfig.json`)
**Action:** Overwrite/Create
**Description:**
- Configure `vite.config.ts` to use `@crxjs/vite-plugin`. This plugin automatically parses `manifest.json` and bundles our entry points (background, offscreen, popup) into a loadable extension.
- Update `tsconfig.json` to allow `webworker` lib (for Service Workers).

### Step 3: Manifest V3 (`src/manifest.json`)
**Action:** Create
**Description:**
Define the extension capabilities.
- **Permissions:** `storage`, `offscreen` (critical for crawler), `scripting`.
- **Host Permissions:** `https://chessly.com/*` (target), `https://explorer.lichess.ovh/*` (API).
- **Background:** `src/background/index.ts` (module).
- **Action:** `src/popup/index.html`.
- **WebAccessibleResources:** `src/offscreen/index.html`.

### Step 4: Shared Types (`src/types.ts`)
**Action:** Create
**Description:**
Define data contracts so the different parts of the extension speak the same language.
```typescript
export interface ExtractedLine {
  opening: string; // "Vienna Gambit"
  chapter: string;
  study: string;
  variation: string; // "Var 1"
  moves: string[]; // ["e4", "e5"...]
  fen: string;     // Resulting position
  stats?: LichessStats;
}

export interface LichessStats {
  white: number;
  black: number;
  draws: number;
}
```

### Step 5: The Crawler Service (`src/offscreen/`)
**Action:** Create `index.html` and `crawler.ts`
**Description:**
- **HTML:** A minimal HTML file that loads `crawler.ts`.
- **TS:**
    - Listen for `chrome.runtime.onMessage` ('START_CRAWL').
    - Implement the **"Polite & Persistent"** logic (Phase 1: Structure, Phase 2: Sequential Iframe). see chessly_crawler.js
    - **Optimization:** Use the `iframe` ID recycling method we designed to keep memory usage low.

### Step 6: The Background Brain (`src/background/index.ts`)
**Action:** Create
**Description:**
- **Lichess API Wrapper:** Implement a throttled fetcher (max 1 request/sec) for `explorer.lichess.ovh`.
- **Offscreen Manager:** Function `setupOffscreenDocument()` to ensure the crawler is alive.
- **Pipeline:**
    1. Listen for `CRAWL_COMPLETE` message.
    2. Iterate through lines.
    3. Use `Chess` (from `chess.js`) to generate FEN.
    4. Store in `chrome.storage.local`.

### Step 7: Popup UI (`src/popup/`)
**Action:** Modify `App.tsx`
**Description:**
- A simple clean UI.
- Button: "Start Extraction".
- Status Bar: "Ready" / "Crawling..." / "Enriching...".
- List: Show a simplified preview of extracted lines count.

## 4. Verification
1.  Run `npm install`.
2.  Run `npm run dev` (This will start the build watcher).
3.  Open Chrome -> `chrome://extensions` -> "Load Unpacked" -> Select the `dist` folder.
4.  Ensure the Popup opens.
5.  Check the "Service Worker" console for errors.
```